---
author: Gregory M. Kapfhammer
title: Automatically detecting and removing ineffective database schema mutants
date: '2020-01-01'
date-format: YYYY
categories: [post, mutation testing, database testing]
description: <em>How can tools automatically detect ineffective mutants?</em>
---

[@Parry2022a] [{{< iconify
fa6-solid book-open>}}](/research/papers/parry2022a/index.qmd)

## Introduction

Data is one of an organization’s most valuable and strategic assets. Testing the
relational database schema, which protects the integrity of this data, is of
paramount importance. Mutation analysis is a means of estimating the
fault-finding “strength” of a test suite. As with program mutation, however,
relational database schema mutation results in many “ineffective” mutants that
both degrade test suite quality estimates and make mutation analysis more time
consuming. This paper presents a taxonomy of ineffective mutants for relational
database schemas, summarizing the root causes of ineffectiveness with a series
of key patterns evident in database schemas. On the basis of these, we introduce
algorithms that automatically detect and remove ineffective mutants. In an
experimental study involving the mutation analysis of 34 schemas used with three
popular relational database management systems—HyperSQL, PostgreSQL, and
SQLite—the results show that our algorithms can identify and discard large
numbers of ineffective mutants that can account for up to 24% of mutants,
leading to a change in mutation score for 33 out of 34 schemas. The tests for
seven schemas were found to achieve 100% scores, indicating that they were
capable of detecting and killing all non-equivalent mutants. The results also
reveal that the execution cost of mutation analysis may be significantly
reduced, especially with “heavyweight” DBMSs like PostgreSQL.

## Background

Relational database schemas define the structure and type of data that will
reside within a database, declaring any relationships between pieces of data
that may exist. Integrity constraints are vital for protecting the validity and
authenticity of database data. There are five common types of constraints:
PRIMARY KEY, UNIQUE, NOT NULL, FOREIGN KEY, and CHECK constraints. Testing these
constraints is crucial to ensure data integrity.

## Mutation Analysis

Mutation analysis estimates the fault-finding capability of a test suite by
generating copies of an artifact under test and seeding small faults, known as
“mutants”, into those copies. The percentage of mutants killed by a test suite
is known as the “mutation score”; the higher the mutation score, the stronger
the suite is judged to be at trapping real faults. However, mutation analysis
can result in the generation of many ineffective mutants, which can be invalid,
equivalent, or redundant. These ineffective mutants reduce the usefulness of the
final mutation score and incur an execution time overhead.

## Ineffective Mutants

Ineffective mutants can manifest in various ways. For instance, PRIMARY KEY
constraints ensure the uniqueness of database table rows, which is also a
property of UNIQUE constraints. This leads to a source of equivalent mutants in
the SQLite DBMS. We identify a wide range of representative root causes of
ineffectiveness in the mutants of relational database schemas and summarize
these root causes into a number of patterns in database schemas that can be used
for ineffective mutant detection. We also introduce a new type of ineffective
mutant: the “impaired” mutant, which represents infeasible database schemas that
are not completely invalid but are trivially killed by test cases.

## Detecting Ineffective Mutants

We present algorithms capable of statically analyzing mutants, identifying those
that are ineffective, and removing them from the mutant pool used in mutation
analysis. These algorithms are implemented in our open-source tool called
SchemaAnalyst. Our experimental study shows that these algorithms can detect and
remove large numbers of ineffective mutants, making mutation scores more useful
and reducing the execution cost of mutation analysis.

## Conclusion

Our research presents a significant step forward in the field of mutation
analysis for relational database schemas. By automatically detecting and
removing ineffective mutants, we can improve the usefulness of mutation scores
and reduce the time needed for mutation analysis. Future work will focus on
extending our methods to handle more complex cases and applying our techniques
to other domains.

::: {.callout-note appearance="simple"}

## Further Details

As my colleagues and continue to explore how machine learning can support the
detection and repair of flaky tests, your insights and suggestions are
appreciated! If you have ideas or experiences related to this pervasive issue
in software testing, please [contact](/contact/) me. Or, if you want to stay
informed about new developments and blog posts related to flaky tests and other
software testing topics, consider [subscribing](/support/) to my mailing list.
Finally, if you would like to listen to me discuss this paper on a podcast,
please check out <a
  href="https://hanselminutes.com/874/dr-gregory-kapfhammer-wants-to-stop-flaky-tests">\"Dr.
  Gregory Kapfhammer Wants to Stop Flaky Tests\"</a>!

:::

{{< include /_back-blog.qmd >}}
